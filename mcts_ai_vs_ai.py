# -*- coding: utf-8 -*-
"""MCTS-AI vs AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sww-iTdmqK8DdsPRIQDROqzxotlibLzt

#Introduction to Artificial Intellingence - Lab MidTerm

###Malaika Sattar FA22-BAI-021
###Sheeza Tanveer FA22-BAI-037

The game we chose is Connect-Four. Connect Four is a two-player, abstract strategy game that is played on a grid. The objective of the game is to be the first player to connect four of their own discs in a row, either horizontally, vertically, or diagonally, within the grid.

##Monte-Carlo Tree Search (MCTS) on Connect-Four - AI VS AI

Firstly, import the necessary libraries required for the implementation. Numpy for mathematical opertaion involving arrays, random for generating random numbers, time measuring time intervals, math for mathematical functions and os for interacting with the operating system.
"""

import numpy as np
import random
import time
import math
import os
#the processing time for the mcts algorithm is set to 3
PROCESS_TIME = 3

"""The GameBoard class is used to set up the basic methods required for the smooth functioning of the game. It initializes the game board, has a function to print the baord using dashes and numbers. It also checks for a win condition by checking diagonally, vertically or horizontally. Further explamation is in the comments:"""

class GameBoard:
    #this is the constructor for game board
    #it takes one parameter cpu
    def __init__(self):
        self.turn = random.randint(1, 2) #randomly selects which player starts (player 1 or player 2)
        self.board = np.zeros(shape=(6, 7)) #initializes a 6x7 numpy array called board to represent the game board

    def show(self): #displays the current state of the game board
        os.system('cls' if os.name == 'nt' else 'clear') #uses the os library to clear the console screen
        print("AI X's turn" if self.turn == 1 else "AI O's turn") #prints which AI's turn is it
        for j in range(5, -1, -1):
            for i in range(7):
                if self.board[j, i] == 1:
                    print(" X ", end="")
                elif self.board[j, i] == 2:
                    print(" O ", end="")
                else:
                    print(" - ", end="")
            print("")
        print(" 0  1  2  3  4  5  6 ")
        print("\n")

    def check_win(self): #it tries to find four consecutively connected game-pieces in order to win the game
        for player in [1, 2]:
            for r in range(6):
                for c in range(7):
                    if self.board[r, c] == player:
                        #checks the winning condition horizontally
                        if c + 3 < 7 and all(self.board[r, c + i] == player for i in range(4)):
                            return player
                        #checks the winning condition vertically
                        if r + 3 < 6 and all(self.board[r + i, c] == player for i in range(4)):
                            return player
                        #checks the winning condition diagonally (up-right)
                        if r + 3 < 6 and c + 3 < 7 and all(self.board[r + i, c + i] == player for i in range(4)):
                            return player
                        #checks the winning condition diagonally (up-left)
                        if r + 3 < 6 and c - 3 >= 0 and all(self.board[r + i, c - i] == player for i in range(4)):
                            return player
        return None #if there in no winner yet, it returns none

"""The MCTS class is where the main implemenatation of the monte-carlo tree serach takes place. Just like any other class it first initializes the class and then has different methods that perform the decision making for the AI as to which move to choose. It has a main method called the compute_move in which all the other methods i.e select(), rollout(), backpropagate() and best_child() are called. Further explanation is in the comments made in the code snippet:"""

class MCTS:
    #initializes an instance of MCTS class
    def __init__(self, symbol, t): #take two parameter symbol and t
        self.symbol = symbol #symbol represents the player's symbol (X or O). This symbol indicates which player the algorithm is playing as.
        self.t = t #the time in seconds in which the algorithm has to make a decision

    #The MAIN function for computing a move using MCTS algorithm
    def compute_move(self, root): #takes one parameter root i.e the node to be expanded
        time0 = time.time()
        while(time.time() - time0) < self.t: #makes sure that the time limit does not exceed the allotted time
            leaf = self.select(root) #traverses the tree, starting from the root node, and returns a leaf node.
            simulation_result = self.rollout(leaf) #simulates a game from the leaf node until a terminal state is reached. The result of this simulation is stored
            self.backpropagate(leaf, simulation_result) #stores the statistics of the nodes based on simulation results
        selected = self.best_child(root) #considering the simulation results, it selects the best child node of the root
        for j in range(6):
            for i in range(7):
                if selected.board[j][i] != root.board[j][i]:
                    return (j, i)

    #traverses from root till leaf node in the selection phase of MCTS
    def select(self, node):
        while(self.fully_expanded(node)): #if all children of node has been expanded
            tmp = self.select_uct(node)  #select best one according to uct value
            if tmp == node:  #if select_uct returns back the node break
                break
            else:  # if not, keep exploring the tree
                node = tmp
        if node.terminal: # if node is terminal, return it
            return node
        else: #if not, then it expands the node and returns one of its unvisited children.
            node.add_child()
            if node.children:
                return self.pick_unvisited(node.children)
            else:
                return node

    #the method for returning the upper bound confidence tree (UCT)
    #UCT is a formula that balances the trade-off between exploration and exploitation in the search tree.
    def select_uct(self, node):
        best_uct = -10000000
        best_node = None
        for child in node.children:
            uct = (child.Q/child.N) + 2*math.sqrt((math.log(node.N))/child.N) #calculates the UCT value for each child of the given node
            if uct > best_uct: #returns the child with the highest UCT value
                best_uct = uct
                best_node = child
        if best_node is None: #condition for handling if node has no children
            return node
        else:
            return best_node

    #checks if all the children of a node have been expanded
    def fully_expanded(self, node):
        visited = True
        if list(node.board[5]).count(0) == len(node.children): #max number of children a node can have
            for child in node.children: #check if every node has been visited
                if child.N == 0:
                    visited = False
            return visited
        else:
            return False

    #method for choosing unexplored nodes
    def pick_unvisited(self, children):
        for child in children: #returns the first child with a visit count of 0.
            if child.N == 0:
                return child

    #performs a rollout simulation from a given node to a terminal state
    def rollout(self, node):
        board = node.board
        turn = node.turn
        if not node.terminal:
            while(True): #switch turn
                if turn == 1:
                    turn = 2
                else:
                    turn = 1
                moves = self.get_moves(board, turn)  #gets moves from current board
                if moves: #simulates the game until it reaches a terminal state (win, lose, or tie)
                    board = random.choice(moves) #selects next board randomly
                    terminal = self.result(board) #checks if state is terminal
                    if terminal != 0: #returns the result
                        return terminal
                else:
                    return self.result(board)
        else:
            return self.result(board)

    #returns all possible next states
    def get_moves(self, board, turn):
        moves = list() #initialzed list where moves will be stored
        for i in range(7): #iterates through each column toc heck if the any of the cell in that column is empty
            if board[5, i] == 0:
                for j in range(6):
                    if board[j, i] == 0:
                        tmp = board.copy() #creates a copy of the current game board and stores it in the tmp variable, copy is essential to avoid modifying the original game board when trying different moves
                        if turn == 1:
                            tmp[j, i] = 2
                        else:
                            tmp[j, i] = 1
                        moves.append(tmp)
                        break
        return moves

    #alculates the result (win, lose, tie) for a given game board Get result score from board
    def result(self, board):
        winner = None
        #checks rows
        for y in range(6):
            row = list(board[y, :])
            for x in range(4):
                if row[x:x+4].count(row[x]) == 4:
                    if row[x] != 0:
                        winner = row[x]
        #checks columns
        for x in range(7):
            col = list(board[:, x])
            for y in range(3):
                if col[y:y+4].count(col[y]) == 4:
                    if col[y] != 0:
                        winner = col[y]
        #checks right diagonals
        points = [(3, 0), (4, 0), (3, 1), (5, 0), (4, 1), (3, 2),
                  (5, 1), (4, 2), (3, 3), (5, 2), (4, 3), (5, 3)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(board[point[0]-k, point[1]+k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                winner = diag[k]
        #checks left diagonals
        points = [(5, 3), (5, 4), (4, 3), (5, 5), (4, 4), (3, 3),
                  (5, 6), (4, 5), (3, 4), (4, 6), (3, 5), (3, 6)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(board[point[0]-k, point[1]-k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                winner = diag[k]
        if winner is None: #if there is no winner
            return 0
        else:
            if self.symbol == winner: #returns whether AI won or not
                return 1 #1 is for win
            else:
                return -1 #-1 is for lose

    def backpropagate(self, node, result): #resursive function to update number of visits and score of each node from leaf to root
        if node.turn == self.symbol:
            node.Q += result #adds result when AI's turn
        else:
            node.Q -= result #or else subtract it
        node.N += 1 # increment visit number by 1
        if node.parent is None: #stop if node is root
            return
        else:
            self.backpropagate(node.parent, result) #calls function recursively on parent

    #returns the child of the given node with the largest number of visits
    def best_child(self, node):
        max_visit = 0 #this variable will be used to keep track of the maximum number of visits among the children of the given node
        best_node = None #this variable will store the child node with the highest number of visits.
        for child in node.children: #iterates through all the children of the input node to check the best node
            if child.N > max_visit:
                max_visit = child.N
                best_node = child
        return best_node

"""The Node is also an important part of the implementation. The Node class represent nodes in the game tree for our game. Each instance of this class represents a specific game state or a particular configuration of the game board and contains information about the state's attributes and properties. It has methods for initializing the nodes, to check whether the terminal state is reached, to add more child and compare children of the node. More explanation is added through comments:"""

class Node:
    def __init__(self, parent, board, turn): #the constructor method for the Node class
        self.Q = 0  #sum of rollout outcomes
        self.N = 0  #number of visits to this node
        self.parent = parent #reference to the parent node in the tree
        self.board = board #representation of the game board for this node.
        if turn == 1: #indicates which player's turn it is at this node
            self.turn = 2
        else:
            self.turn = 1
        self.children = [] #list that will store references to child nodes
        self.expanded = False #checks whether child nodes have been expanded from this node
        self.terminal = self.check_terminal() #checks if the terminal state is recahed or not

    def check_terminal(self): # if the game state represented by the current node is terminal
        #checks winning combinations in rows
        for y in range(6):
            row = list(self.board[y, :])
            for x in range(4):
                if row[x:x+4].count(row[x]) == 4:
                    if row[x] != 0:
                        return True
        #checks winning combinations in columns
        for x in range(7):
            col = list(self.board[:, x])
            for y in range(3):
                if col[y:y+4].count(col[y]) == 4:
                    if col[y] != 0:
                        return True
        #checks winning combinations in right diagonals
        points = [(3, 0), (4, 0), (3, 1), (5, 0), (4, 1), (3, 2),
                  (5, 1), (4, 2), (3, 3), (5, 2), (4, 3), (5, 3)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(self.board[point[0]-k, point[1]+k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                return True
        #checks winning combinations in left diagonals
        points = [(5, 3), (5, 4), (4, 3), (5, 5), (4, 4), (3, 3),
                  (5, 6), (4, 5), (3, 4), (4, 6), (3, 5), (3, 6)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(self.board[point[0]-k, point[1]-k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                return True
        #if no winner yet then return false
        return False
        #if all the possible moves have been done
        if list(self.board.flatten()).count(0) == 0:
            return True

    def add_child(self): #this method is used to add child nodes to the current node
        if self.expanded: #if node is already expnanded return
            return
        child_board = list()
        for child in self.children: #checks the game board for every possible move (dropping a piece in each column)
            child_board.append(child.board) #creates new child nodes for each valid move.
        for i in range(7):
            if self.board[5, i] == 0:
                for j in range(6):
                    if self.board[j, i] == 0:
                        tmp = self.board.copy() #for each valid move, it creates a copy of the current game board,
                        if self.turn == 1:
                            tmp[j, i] = 2
                            if child_board:
                                if not self.compare_children(tmp, child_board): #simulates the move by updating the copy
                                    self.children.append(Node(self, tmp, 1)) #creates a new child node with the modified board
                                    return
                                else:
                                    break
                            else:
                                self.children.append(Node(self, tmp, 1))
                                return
                        else:
                            tmp[j, i] = 1
                            if child_board:
                                if not self.compare_children(tmp, child_board):
                                    self.children.append(Node(self, tmp, 2))
                                    return
                                else:
                                    break
                            else:
                                self.children.append(Node(self, tmp, 2))
                                return
        self.expanded = True
        return

    def compare_children(self, new_child, children): #checks if a potential new child node already exists among the list of children nodes
        for child in children: #if the new child node's board matches the board of any existing child node, the method returns True
            if (new_child == child).all():
                return True
        return False

"""This is the main method for playing the game of connect four between an AI and an AI. It first print the prompt explaining the game rules and calls the classes GameBaord and MCTS and thus the game proceeds. It contains the conditions for whether the AI X won or the AI O won and then displays the results accordingly. Further explanation is in code:"""

if __name__ == "__main__":
    print("Welcome to Connect 4!")
    print("The goal of the game is to connect four of your pieces either horizontally, vertically, or diagonally.")
    print("The AI X will play against AI O.")
    print("Let's start the game!")

    gameBoard = GameBoard() #ame board is initialized using the GameBoard class, creating an instance called gameBoard
    #two instances of the MCTS class are created, one for AI X and one for AI O (both are initialized with time 5 seconds)
    monteCarloX = MCTS(symbol=1, t=5)
    monteCarloO = MCTS(symbol=2, t=5)

    while True:  # main game loop this loop will keep the game running until it's explicitly exited within the loop.
        gameBoard.show() #displays the current state of the game board.
        winner = gameBoard.check_win() #checks if there's a winner by calling the check_win() method of the GameBoard class.
        if winner is not None:
            if winner == 1:
                print("\nAI X WON!!!")
            else:
                print("\nAI O WON!!!")
            break
        else:
            if list(gameBoard.board.flatten()).count(0) == 0:
                print("\nTIE!!!") #if there are no empty cells left, the game is declared a tie, and the loop is exited
                break
        #depending on the current player's turn (as represented by gameBoard.turn), the corresponding AI player is selected to make a move
        if gameBoard.turn == 1:
            root = Node(parent=None, board=gameBoard.board, turn=monteCarloX.symbol) #AI player's move is calculated by creating a Node object called root
            move = monteCarloX.compute_move(root) #AI's move is determined using the monteCarloX's compute_move method
            gameBoard.board[move[0], move[1]] = monteCarloX.symbol #game board is updated with the AI's move by setting the appropriate cell to the AI player's symbol
            gameBoard.turn = 2 #switches turn to other AI
        else:
            root = Node(parent=None, board=gameBoard.board, turn=monteCarloO.symbol) ##AI player's move is calculated by creating a Node object called root
            move = monteCarloO.compute_move(root) ##AI's move is determined using the monteCarloO's compute_move method
            gameBoard.board[move[0], move[1]] = monteCarloO.symbol ##game board is updated with the AI's move by setting the appropriate cell to the AI player's symbol
            gameBoard.turn = 1 #switches turn to other AI