# -*- coding: utf-8 -*-
"""MCTS-Human vs AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h_L5i3nosBqZEGzq-DoDzf8s-l_mJdnB

#Introduction to Artificial Intellingence - Lab MidTerm

###Malaika Sattar FA22-BAI-021
###Sheeza Tanveer FA22-BAI-037

The game we chose is Connect-Four. Connect Four is a two-player, abstract strategy game that is played on a grid. The objective of the game is to be the first player to connect four of their own discs in a row, either horizontally, vertically, or diagonally, within the grid.

##Monte-Carlo Tree Search (MCTS) on Connect-Four - Human VS AI

Firstly, import the necessary libraries required for the implementation. Numpy for mathematical opertaion involving arrays, random for generating random numbers, time measuring time intervals, math for mathematical functions and os for interacting with the operating system.
"""

import numpy as np
import random
import time
import math
import os
#the processing time for the mcts algorithm is set to 3
PROCESS_TIME = 3

"""The GameBoard class is used to set up the basic methods required for the smooth functioning of the game. It initializes the game board, has a function to print the baord usiNg dashes and numbers. it also has the function to handle player moves which is where the input value from the user is also taken. It also checks for a win condition by checking diagonally, vertically or horizontally. The methods for applying moves to the board, and switching turns between players i.e human and AI are also in this class. Further explamation is in the comments:"""

class GameBoard:
  #this is the constructor for game board
  #it takes one parameter cpu
    def __init__(self, cpu):
        self.turn = random.randint(1, 2) #randomly selects which player starts (player 1 or player 2)
        self.board = np.zeros(shape=(6, 7)) #initializes a 6x7 numpy array called board to represent the game board
        self.cpu = cpu #stores the cpu value for later reference.

    #displays the current state of the game board
    def show(self):
        os.system('cls' if os.name == 'nt' else 'clear') #uses the os library to clear the console screen
        print("AI's turn[X]" if self.turn == self.cpu else "Player's turn[O]") #prints whose turn is it
        #for loop for printing the board
        for j in range(5, -1, -1):
            for i in range(7):
                if self.board[j, i] == 1:
                    print(" X ", end="")
                elif self.board[j, i] == 2:
                    print(" O ", end="")
                else:
                    print(" - ", end="")
            print("")
        print(" 0  1  2  3  4  5  6 ")
        print("\n")

    #method that prompts the user to enter
    def play(self):
        try:
            move = int(input("Select a column (0-6): "))  #input prompt
            #if condition that checks whether the move is valid or not, if it is valid then it places the symbol O or X
            if move in range(7):
                for i in range(6):
                    if self.board[i, move] == 0:
                        self.board[i, move] = self.turn
                        self.switch_turn() #after one player is done it switched the turns so that AI can have it's move
                        return True #since the value is valid here it returns true
                return False
            else:
                return False #if value is invalid it returns false
        except ValueError:
            return False

    def check_win(self): #it tries to find four consecutively connected game-pieces in order to win the game
        #checks the winning condition in rows
        for y in range(6):
            row = list(self.board[y, :])
            for x in range(4):
                if row[x:x+4].count(row[x]) == 4:
                    if row[x] != 0:
                        return row[x]
        #checks the winning condition in columns
        for x in range(7):
            col = list(self.board[:, x])
            for y in range(3):
                if col[y:y+4].count(col[y]) == 4:
                    if col[y] != 0:
                        return col[y]
        #checks the winning condition in right diagonals
        points = [(3, 0), (4, 0), (3, 1), (5, 0), (4, 1), (3, 2),
                  (5, 1), (4, 2), (3, 3), (5, 2), (4, 3), (5, 3)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(self.board[point[0]-k, point[1]+k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                return diag[0]
        #checks the winning condition in left diagonals
        points = [(5, 3), (5, 4), (4, 3), (5, 5), (4, 4), (3, 3),
                  (5, 6), (4, 5), (3, 4), (4, 6), (3, 5), (3, 6)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(self.board[point[0]-k, point[1]-k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                return diag[0]
        #if there in no winner yet, it returns none
        return None

    #the method that applies the move,the game pices is placed in the column entered by the user
    def apply_move(self, column):
        for i in range(6):
            if self.board[i, column - 1] == 0:
                self.board[i, column - 1] = self.turn
                self.switch_turn()
                return True
        return False

    #the method that switches turns, it is called in the play(self) method to switch turns
    def switch_turn(self):
        if self.turn == 1:
            self.turn = 2
        else:
            self.turn = 1

"""The MCTS class is where the main implemenatation of the monte-carlo tree serach takes place. Just like any other class it first initializes the class and then has different methods that perform the decision making for the AI as to which move to choose. It has a main method called the compute_move in which all the other methods i.e select(), rollout(), backpropagate() and best_child() are called. Further explanation is in the comments made in the code snippet:"""

class MCTS:
    #initializes an instance of MCTS class
    def __init__(self, symbol, t): #take two parameter symbol and t
        self.symbol = symbol #symbol represents the player's symbol (X or O). This symbol indicates which player the algorithm is playing as.
        self.t = t #the time in seconds in which the algorithm has to make a decision

    #The MAIN function for computing a move using MCTS algorithm
    def compute_move(self, root): #takes one parameter root i.e the node to be expanded
        time0 = time.time()
        while(time.time() - time0) < self.t: #makes sure that the time limit does not exceed the allotted time
            leaf = self.select(root) #traverses the tree, starting from the root node, and returns a leaf node.
            simulation_result = self.rollout(leaf) #simulates a game from the leaf node until a terminal state is reached. The result of this simulation is stored
            self.backpropagate(leaf, simulation_result) #stores the statistics of the nodes based on simulation results
        selected = self.best_child(root) #considering the simulation results, it selects the best child node of the root
        for j in range(6):
            for i in range(7):
                if selected.board[j][i] != root.board[j][i]:
                    return (j, i)

    #traverses from root till leaf node in the selection phase of MCTS
    def select(self, node):
        while(self.fully_expanded(node)): #if all children of node has been expanded
            tmp = self.select_uct(node)  #select best one according to uct value
            if tmp == node:  #if select_uct returns back the node break
                break
            else:  # if not, keep exploring the tree
                node = tmp
        if node.terminal: # if node is terminal, return it
            return node
        else: #if not, then it expands the node and returns one of its unvisited children.
            node.add_child()
            if node.children:
                return self.pick_unvisited(node.children)
            else:
                return node

    #the method for returning the upper bound confidence tree (UCT)
    #UCT is a formula that balances the trade-off between exploration and exploitation in the search tree.
    def select_uct(self, node):
        best_uct = -10000000
        best_node = None
        for child in node.children:
            uct = (child.Q/child.N) + 2*math.sqrt((math.log(node.N))/child.N) #calculates the UCT value for each child of the given node
            if uct > best_uct: #returns the child with the highest UCT value
                best_uct = uct
                best_node = child
        if best_node is None: #condition for handling if node has no children
            return node
        else:
            return best_node

    #checks if all the children of a node have been expanded
    def fully_expanded(self, node):
        visited = True
        if list(node.board[5]).count(0) == len(node.children): #max number of children a node can have
            for child in node.children: #check if every node has been visited
                if child.N == 0:
                    visited = False
            return visited
        else:
            return False

    #method for choosing unexplored nodes
    def pick_unvisited(self, children):
        for child in children: #returns the first child with a visit count of 0.
            if child.N == 0:
                return child

    #performs a rollout simulation from a given node to a terminal state
    def rollout(self, node):
        board = node.board
        turn = node.turn
        if not node.terminal:
            while(True): #switch turn
                if turn == 1:
                    turn = 2
                else:
                    turn = 1
                moves = self.get_moves(board, turn)  #gets moves from current board
                if moves: #simulates the game until it reaches a terminal state (win, lose, or tie)
                    board = random.choice(moves) #selects next board randomly
                    terminal = self.result(board) #checks if state is terminal
                    if terminal != 0: #returns the result
                        return terminal
                else:
                    return self.result(board)
        else:
            return self.result(board)

    #returns all possible next states
    def get_moves(self, board, turn):
        moves = list() #initialzed list where moves will be stored
        for i in range(7): #iterates through each column toc heck if the any of the cell in that column is empty
            if board[5, i] == 0:
                for j in range(6):
                    if board[j, i] == 0:
                        tmp = board.copy() #creates a copy of the current game board and stores it in the tmp variable, copy is essential to avoid modifying the original game board when trying different moves
                        if turn == 1:
                            tmp[j, i] = 2
                        else:
                            tmp[j, i] = 1
                        moves.append(tmp)
                        break
        return moves

    #alculates the result (win, lose, tie) for a given game board Get result score from board
    def result(self, board):
        winner = None
        #checks rows
        for y in range(6):
            row = list(board[y, :])
            for x in range(4):
                if row[x:x+4].count(row[x]) == 4:
                    if row[x] != 0:
                        winner = row[x]
        #checks columns
        for x in range(7):
            col = list(board[:, x])
            for y in range(3):
                if col[y:y+4].count(col[y]) == 4:
                    if col[y] != 0:
                        winner = col[y]
        #checks right diagonals
        points = [(3, 0), (4, 0), (3, 1), (5, 0), (4, 1), (3, 2),
                  (5, 1), (4, 2), (3, 3), (5, 2), (4, 3), (5, 3)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(board[point[0]-k, point[1]+k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                winner = diag[k]
        #checks left diagonals
        points = [(5, 3), (5, 4), (4, 3), (5, 5), (4, 4), (3, 3),
                  (5, 6), (4, 5), (3, 4), (4, 6), (3, 5), (3, 6)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(board[point[0]-k, point[1]-k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                winner = diag[k]
        if winner is None: #if there is no winner
            return 0
        else:
            if self.symbol == winner: #returns whether AI won or not
                return 1 #1 is for win
            else:
                return -1 #-1 is for lose

    def backpropagate(self, node, result): #resursive function to update number of visits and score of each node from leaf to root
        if node.turn == self.symbol:
            node.Q += result #adds result when AI's turn
        else:
            node.Q -= result #or else subtract it
        node.N += 1 # increment visit number by 1
        if node.parent is None: #stop if node is root
            return
        else:
            self.backpropagate(node.parent, result) #calls function recursively on parent

    #returns the child of the given node with the largest number of visits
    def best_child(self, node):
        max_visit = 0 #this variable will be used to keep track of the maximum number of visits among the children of the given node
        best_node = None #this variable will store the child node with the highest number of visits.
        for child in node.children: #iterates through all the children of the input node to check the best node
            if child.N > max_visit:
                max_visit = child.N
                best_node = child
        return best_node

"""The Node is also an important part of the implementation. The Node class represent nodes in the game tree for our game. Each instance of this class represents a specific game state or a particular configuration of the game board and contains information about the state's attributes and properties. It has methods for initializing the nodes, to check whether the terminal state is reached, to add more child and compare children of the node. More explanation is added through comments:"""

class Node:
    def __init__(self, parent, board, turn): #the constructor method for the Node class
        self.Q = 0  #sum of rollout outcomes
        self.N = 0  #number of visits to this node
        self.parent = parent #reference to the parent node in the tree
        self.board = board #representation of the game board for this node.
        if turn == 1: #indicates which player's turn it is at this node
            self.turn = 2
        else:
            self.turn = 1
        self.children = [] #list that will store references to child nodes
        self.expanded = False #checks whether child nodes have been expanded from this node
        self.terminal = self.check_terminal() #checks if the terminal state is recahed or not

    def check_terminal(self): # if the game state represented by the current node is terminal
        #checks winning combinations in rows
        for y in range(6):
            row = list(self.board[y, :])
            for x in range(4):
                if row[x:x+4].count(row[x]) == 4:
                    if row[x] != 0:
                        return True
        #checks winning combinations in columns
        for x in range(7):
            col = list(self.board[:, x])
            for y in range(3):
                if col[y:y+4].count(col[y]) == 4:
                    if col[y] != 0:
                        return True
        #checks winning combinations in right diagonals
        points = [(3, 0), (4, 0), (3, 1), (5, 0), (4, 1), (3, 2),
                  (5, 1), (4, 2), (3, 3), (5, 2), (4, 3), (5, 3)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(self.board[point[0]-k, point[1]+k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                return True
        #checks winning combinations in left diagonals
        points = [(5, 3), (5, 4), (4, 3), (5, 5), (4, 4), (3, 3),
                  (5, 6), (4, 5), (3, 4), (4, 6), (3, 5), (3, 6)]
        for point in points:
            diag = list()
            for k in range(4):
                diag.append(self.board[point[0]-k, point[1]-k])
            if diag.count(1) == 4 or diag.count(2) == 4:
                return True
        #if no winner yet then return false
        return False
        #if all the possible moves have been done
        if list(self.board.flatten()).count(0) == 0:
            return True

    def add_child(self): #this method is used to add child nodes to the current node
        if self.expanded: #if node is already expnanded return
            return
        child_board = list()
        for child in self.children: #checks the game board for every possible move (dropping a piece in each column)
            child_board.append(child.board) #creates new child nodes for each valid move.
        for i in range(7):
            if self.board[5, i] == 0:
                for j in range(6):
                    if self.board[j, i] == 0:
                        tmp = self.board.copy() #for each valid move, it creates a copy of the current game board,
                        if self.turn == 1:
                            tmp[j, i] = 2
                            if child_board:
                                if not self.compare_children(tmp, child_board): #simulates the move by updating the copy
                                    self.children.append(Node(self, tmp, 1)) #creates a new child node with the modified board
                                    return
                                else:
                                    break
                            else:
                                self.children.append(Node(self, tmp, 1))
                                return
                        else:
                            tmp[j, i] = 1
                            if child_board:
                                if not self.compare_children(tmp, child_board):
                                    self.children.append(Node(self, tmp, 2))
                                    return
                                else:
                                    break
                            else:
                                self.children.append(Node(self, tmp, 2))
                                return
        self.expanded = True
        return

    def compare_children(self, new_child, children): #checks if a potential new child node already exists among the list of children nodes
        for child in children: #if the new child node's board matches the board of any existing child node, the method returns True
            if (new_child == child).all():
                return True
        return False

"""This is the main method for playing the game of connect four between an AI and a human. It first print the prompt explaining the game rules and calls the classes GameBaord and MCTS and thus the game proceeds. It contains the conditions for whether the human won or the AI won and then displays accordingly. Further explanation is in code:"""

if __name__ == "__main__":
    print("Welcome to Connect 4!")
    print("The goal of the game is to connect four of your pieces either horizontally, vertically, or diagonally.")
    print("You will play as 'O', and the AI will play as 'X'.")
    print("To make a move, enter the column number (0-6) where you want to drop your piece.")
    print("Let's start the game!")
    while True: # main game loop this loop will keep the game running until it's explicitly exited within the loop.
        gameBoard = GameBoard(cpu=1) #gameBoard is an instance of the GameBoard class, initialized with the AI's symbol as 'X' (1 means X)
        monteCarlo = MCTS(symbol=1, t=3) #monteCarlo is an instance of the MCTS class, initialized with the AI's symbol as 'X' and a time limit of 5 seconds

        while True: #this loop represents the ongoing gameplay.
            gameBoard.show() #displays the current state of the game board.
            winner = gameBoard.check_win() #checks if there's a winner by calling the check_win method of the GameBoard class.
            if winner is not None:
                if winner == gameBoard.cpu:
                    print("\n\nAI WON!!!")
                else:
                    print("\n\nPLAYER WON!!!")
                break
            else:
                if list(gameBoard.board.flatten()).count(0) == 0:
                    print("\n\nTIE!!!")
                    break

            if gameBoard.turn == monteCarlo.symbol: #AI's turn
                root = Node(parent=None, board=gameBoard.board, turn=monteCarlo.symbol) #a Node object called root is created, representing the current state of the game board
                move = monteCarlo.compute_move(root) #AI's move is computed
                gameBoard.board[move[0], move[1]] = monteCarlo.symbol #AI's move is applied to the game board by updating the board with the AI's symbol in the chosen column and row.
                gameBoard.switch_turn() #switches the turn to player
            else:
                while not gameBoard.play():
                    print("Invalid move. Please select a column (0-6).")
        break